import streamlit as st
import openai
import requests

openai.api_key = 'YOUR_OPENAI_API_KEY'
omdb_api_key = 'YOUR_OMDB_API_KEY'

def get_movie_poster(movie_title):
    """
    Fetches the movie poster URL from the OMDb API based on the given movie title.
    
    Parameters:
    movie_title (str): The title of the movie for which to retrieve the poster.
    
    Returns:
    str: URL of the movie poster if found; otherwise, returns a placeholder image URL.
    """
    url = f"http://www.omdbapi.com/?t={movie_title}&apikey={omdb_api_key}"
    response = requests.get(url)
    data = response.json()
    poster_url = data.get('Poster')
    
    # Return the poster URL or a placeholder if not available
    if poster_url and poster_url != "N/A":
        return poster_url
    else:
        return "https://via.placeholder.com/150x225.png?text=No+Image"

def get_movie_recommendations(genres, favorite_movies):
    """
    Generates personalized movie recommendations using the OpenAI API based on 
    the user's favorite genres and top 3 movies.
    
    Parameters:
    genres (list of str): A list of the user's favorite movie genres.
    favorite_movies (list of str): A list of the user's top 3 favorite movies.
    
    Returns:
    tuple:
        - str: A table formatted string of recommended movies generated by the OpenAI API.
        - list of str: A list of movie names extracted from the OpenAI API response.
    """
    prompt = f"""
    I love the following movie genres: {', '.join(genres)}. 
    My top 3 favorite movies are: {', '.join(favorite_movies)}. 
    Based on these preferences, could you recommend me some movies in a table format? 
    The table should include the movie name, genre, and a brief summary of the plot.
    """
    response = openai.ChatCompletion.create(
        model="gpt-4",
        messages=[
            {"role": "system", "content": "You are a helpful assistant."},
            {"role": "user", "content": prompt},
        ]
    )
    
    recommendations = response.choices[0].message['content']
    
    # Extract movie names from the response
    recommended_movies = []
    for line in recommendations.split("\n"):
        if "|" in line:
            parts = line.split("|")
            if len(parts) >= 3:
                movie_name = parts[1].strip()
                recommended_movies.append(movie_name)

    return recommendations, recommended_movies

def get_new_recommendations(genres, favorite_movies):
    """
    Generates new movie recommendations using existing information (genres and favorite movies)
    without asking for additional user input.

    Parameters:
    genres (list of str): A list of the user's favorite movie genres.
    favorite_movies (list of str): A list of the user's top 3 favorite movies.

    Returns:
    tuple:
        - str: A new table formatted string of recommended movies generated by the OpenAI API.
        - list of str: A list of new movie names extracted from the OpenAI API response.
    """
    prompt = f"""
    The user did not like the previous movie recommendations. Based on the following preferences:
    Genres: {', '.join(genres)}.
    Top 3 favorite movies: {', '.join(favorite_movies)}.
    Please suggest different movies in a table format. The table should include the movie name, genre, and a brief summary of the plot.
    Do not ask for additional information, just provide new recommendations.
    """
    response = openai.ChatCompletion.create(
        model="gpt-4",
        messages=[
            {"role": "system", "content": "You are a helpful assistant."},
            {"role": "user", "content": prompt},
        ]
    )
    
    recommendations = response.choices[0].message['content']
    
    # Extract movie names from the new recommendations
    new_recommended_movies = []
    for line in recommendations.split("\n"):
        if "|" in line:
            parts = line.split("|")
            if len(parts) >= 3:
                movie_name = parts[1].strip()
                new_recommended_movies.append(movie_name)

    return recommendations, new_recommended_movies

def validate_table_format(recommendations):
    """
    Validates that the recommendations are in the correct table format.
    
    Parameters:
    recommendations (str): The string containing the movie recommendations.
    
    Returns:
    bool: True if the format is correct, False otherwise.
    """
    lines = recommendations.split("\n")
    if len(lines) < 3:
        return False
    headers = lines[1].strip().split("|")
    if len(headers) < 4:
        return False
    if headers[1].strip().lower() != "movie name" or headers[2].strip().lower() != "genre" or headers[3].strip().lower() != "brief summary":
        return False
    return True

def repair_recommendations_format(recommendations):
    """
    Attempts to repair the recommendations table format by ensuring each line has the correct number of columns.
    
    Parameters:
    recommendations (str): The string containing the movie recommendations.
    
    Returns:
    str: The repaired recommendation string.
    """
    lines = recommendations.split("\n")
    repaired_lines = []
    for line in lines:
        if "|" in line:
            parts = line.split("|")
            if len(parts) < 4:
                # Attempt to repair by adding missing columns
                parts += [" "] * (4 - len(parts))
            repaired_lines.append("|".join(parts))
        else:
            repaired_lines.append(line)
    return "\n".join(repaired_lines)

def main():
    """
    Main function to run the Streamlit app. It gathers user input for movie genres 
    and favorite movies, fetches movie recommendations using OpenAI, displays 
    the recommendations, shows corresponding posters, and collects user feedback.
    
    Based on the feedback, it can either confirm that the user liked the recommendations 
    or generate new recommendations.
    """
    # Set page title and configuration
    st.set_page_config(page_title="Movie Recommendation System", layout="centered")

    # Custom CSS for dark theme and better styling
    st.markdown("""
        <style>
        body {
            background-color: #121212;
            color: #e0e0e0;
        }
        .stTextInput input, .stSelectbox select {
            background-color: #303030;
            color: #e0e0e0;
            border: 2px solid #ff4081;
            border-radius: 10px;
            padding: 10px;
            font-size: 16px;
        }
        .recommendations-table {
            background-color: #1f1f1f;
            border: 2px solid #ff4081;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            color: #e0e0e0;
            font-family: monospace;
        }
        .stButton>button {
            background-color: #ff4081;
            color: white;
            border-radius: 50px;
            padding: 15px 30px;
            font-size: 18px;
            font-weight: bold;
            border: none;
        }
        .stButton>button:hover {
            background-color: #e91e63;
            color: white;
            transform: scale(1.05);
            transition: all 0.3s ease;
        }
        .poster-image {
            display: inline-block;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        .movie-recommendations {
            display: flex;
            flex-wrap: wrap;
            justify-content: flex-start;
        }
        .movie-recommendations > div {
            flex: 0 0 30%; /* 3 posters per row */
            max-width: 30%;
        }
        .stSelectbox {
            padding-top: 0;
            padding-bottom: 0;
        }
        .stSelectbox label {
            display: none;
        }
        </style>
        """, unsafe_allow_html=True)

    # Title and description
    st.title("Movie Recommendation System")
    st.markdown("### How It Works")
    st.markdown("""
        1. Select your favorite movie genres.
        2. Enter your top 3 favorite movies.
        3. Submit your preferences.
        4. Get personalized movie recommendations!
    """)

    # User input form
    genres = st.multiselect(
        label="Select your favorite movie genres:",
        options=[
            "Action", "Comedy", "Drama", "Science Fiction", "Horror",
            "Romance", "Thriller", "Adventure", "Animation", "Documentary",
            "Crime", "Fantasy", "Musical", "War", "Western",
            "Film Noir", "Humor", "Family", "Biography", "History"
        ]
    )
    
    favorite_movies = [
        st.text_input(f"Movie {i+1}") for i in range(3)
    ]
    
    submit_button = st.button("Get Recommendations")

    if submit_button:
        if genres and all(favorite_movies):
            # Get movie recommendations and extract movie names
            recommendations, recommended_movies = get_movie_recommendations(genres, favorite_movies)
            
            # Validate and repair the recommendations table format
            if not validate_table_format(recommendations):
                recommendations = repair_recommendations_format(recommendations)
            
            # Display the recommendations table
            st.markdown("#### Recommended Movies")
            st.markdown(f"<div class='recommendations-table'>{recommendations}</div>", unsafe_allow_html=True)
            
            # Display posters of recommended movies in a row
            st.markdown("### Posters of Recommended Movies")
            st.markdown("<div class='movie-recommendations'>", unsafe_allow_html=True)
            for movie in recommended_movies:
                poster_url = get_movie_poster(movie)
                st.markdown(f"<div class='poster-image'><img src='{poster_url}' width='150'><br>{movie}</div>", unsafe_allow_html=True)
            st.markdown("</div>", unsafe_allow_html=True)
            
            # Save recommendation state
            st.session_state['recommendations'] = recommendations
            st.session_state['recommended_movies'] = recommended_movies
            st.session_state['show_feedback'] = True  # Show feedback only after recommendations are shown

    # Check if recommendations are available and feedback question should be shown
    if 'recommendations' in st.session_state and st.session_state.get('show_feedback', False):
        st.markdown("### Did You Like These Recommendations?")
        col1, col2 = st.columns(2)
        
        # If "Yes" button is clicked
        if col1.button("Yes"):
            st.success("We are thrilled that you loved the recommendations! We'll continue to suggest similar movies.")
            # Clear session state for recommendations
            st.session_state.pop('recommendations', None)
            st.session_state.pop('recommended_movies', None)
            st.session_state.pop('show_feedback', None)

        # If "No" button is clicked
        if col2.button("No"):
            st.warning("We're sorry that the recommendations didn't meet your expectations. Let me suggest new movies.")
            genres = st.session_state.get('genres', [])
            favorite_movies = st.session_state.get('favorite_movies', [])
            new_recommendations, new_recommended_movies = get_new_recommendations(genres, favorite_movies)
            if not validate_table_format(new_recommendations):
                new_recommendations = repair_recommendations_format(new_recommendations)
            
            st.markdown("#### New Recommended Movies")
            st.markdown(f"<div class='recommendations-table'>{new_recommendations}</div>", unsafe_allow_html=True)
            
            # Display posters of new recommended movies in a row
            st.markdown("### Posters of New Recommended Movies")
            st.markdown("<div class='movie-recommendations'>", unsafe_allow_html=True)
            for movie in new_recommended_movies:
                poster_url = get_movie_poster(movie)
                st.markdown(f"<div class='poster-image'><img src='{poster_url}' width='150'><br>{movie}</div>", unsafe_allow_html=True)
            st.markdown("</div>", unsafe_allow_html=True)
            # Update session state with new recommendations
            st.session_state['recommendations'] = new_recommendations
            st.session_state['recommended_movies'] = new_recommended_movies

if __name__ == "__main__":
    main()
